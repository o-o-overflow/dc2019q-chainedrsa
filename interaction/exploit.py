"""
Tiffany's solution:
    0. check out the paper
    1. The public key header hints the key is PKCS#1.2. It is clearly
    written in the "standard" --- PKCS1v2, RFC 2437.
    (https://stackoverflow.com/questions/18039401/how-can-i-transform-between-the-two-styles-of-public-key-format-one-begin-rsa).
    2. ed = k * lambda(N) - 1, intead of ed = k * phi(N) - 1.
    lambda(N) is the lcm of (p-1), (q-1), not the multiplication of
    (p-1) and (q-1).
    3. The paper's solution need to be edited because of the use of lcm 4.
    4. And you need to add optimizations to improve the performance.
    5. Actually you don't need all optimizations. We loose the time in
    case of network latency. I ran it during the game and this can be
    done in 3 minutes in my laptop.
Tiffany's mistakes:
    1. key corpus is too small
    2. same message all the time
"""


#!/usr/bin/env python2

from pwn import *
import sys
from Crypto.PublicKey import RSA
# from Crypto.Cipher import PKCS1_OAEP
from Crypto.Cipher import PKCS1_v1_5
from binascii import unhexlify, hexlify
from   Crypto.Util.strxor import strxor
from Crypto.Util.number import long_to_bytes

MAX_G = 300

PUBLICKEYHEADER = '-----BEGIN PUBLIC KEY-----'

CORRECT = 'Yes, continue'
SUCCESS = 'Yes, and now you know the flag'


class Case(object):
    def __init__(self, n, e, ld, length, private=None):
        self.n = n
        self.e = e
        self.ld = ld
        self.d_hl = length
        self.private = private
        # self.k = (self.e * self.d - 1) / lcm(self.p-1, self.q-1)

    def __str__(self):
        e = 'e: %d' % self.e
        d = 'd: %s' % bin(self.d)
        g = 'g: %d' % self.g
        k = 'k: %d' % self.k

        return '\n'.join([p, q, e, d, g, k])

    def gcd(self, a, b):
        while b:
            a, b = b, a % b
        return a

    def upper_half(self, n):
        half_bit_length = n.bit_length() / 2 + 1
        return n >> half_bit_length

    def is_sqrt(self, n):
        # This is an efficient sqrt
        x = n
        y = (x + 1) // 2
        while y < x:
            x = y
            y = (x + n // x) // 2
        return x ** 2 == n

    def test(self, d, e, n, g, k):
        # One way is to test with a msg. But it can be very slow
        # due to exponentiation. So we use sqrt trick with a filter.
        # 1. This improves performance by avoiding sqrt
        if (d * e - 1) % k != 0:
        # if (d * e - 1) % g != 0 or (d * e - 1) % k != 0:
            return False
        phi = (d * e - 1) * g / k
        sum_pq = n + 1 - phi
        # 2. This improves performance by avoiding decrypting
        if sum_pq != n+1 and self.is_sqrt(sum_pq ** 2 - 4 * n):
            return True
        else:
            return False

    def calculate(self):
        g = 1
        while True:
            # 3. This improves performance
            if (self.n - 1) % g > 0:
                g += 1
                continue
            print "Guessing g =", g
            for k in xrange(1, g * self.e):
                # 4. This improves performance
                if self.gcd(k, g) > 1 : continue
                d0 = (k * (self.n+1) + g) / (self.e * g)
                dd0 = self.upper_half(d0)
                d = (dd0 << self.d_hl) + self.ld
                d_minus = (dd0 - 1 << self.d_hl) + self.ld
                # d0 may carry 1, e.g. n = 61 * 53, e = 17, d = 413
                if self.test(d, self.e, self.n, g, k):
                    return d
                if self.test(d_minus, self.e, self.n, g, k):
                    return d_minus
            g += 1
            if g > MAX_G:
                return None
    def decrypt(self, d, msg):
        # print "length: ", len(msg)
        unhexlified_msg = unhexlify(msg)
        private = RSA.construct((self.n, self.e, d))
        decryptor = PKCS1_v1_5.new(private)
        decrypted = decryptor.decrypt(unhexlified_msg, 1)
        return decrypted

    def xor_strings(self, s, t):
        """
        xor two strings together by first getting their ascii code values
        and then xor'ing them
        reference: https://github.com/morganda/crypto_hacks/blob/master/xor_strings/xor_strings.py
        """
        # ord returns an integer of the ascii code of a given one char string
        # chr returns a one char string from a given ascii code value
        # hexlify turns the given string into a hex string
        return hexlify(''.join(chr(ord(a)^ord(b)) for a, b in zip(s, t)))


def start(conn, old_d_bytes):
    print "Start again"

    # read public key
    result = conn.recvuntil(PUBLICKEYHEADER)
    publickey = PUBLICKEYHEADER + conn.recvuntil('-----END PUBLIC KEY-----')
    pubkey = RSA.importKey(publickey)
    # print pubkey.n

    result = conn.recvuntil('Hint: ')
    hint = conn.recvline(keepends=False)
    lower_d, length = hint.split(',')
    length = int(length)
    half_d = int(lower_d, 16)
    # print 'hint:', bin(half_d)
    # print 'length: ', length

    # Receive Encrypted Message
    result = conn.recvuntil('Encrypted Msg: ')
    msg = conn.recvuntil('\nInput a string:\n', drop=True)
    # print "Msg: ", msg
    # msg = constructmsg(half_d)

    case = Case(pubkey.n, pubkey.e, half_d, length)
    d = case.calculate()
    if d is None:
        print "Cannot find d"
        return None, None
    decrypted = case.decrypt(d, msg)
    print "Decrypted: ", hexlify(decrypted)

    low_new_d_bytes = long_to_bytes(half_d)
    # print "bytes: ", hexlify(low_new_d_bytes[0])
    # print "old d bytes: %d" % len(old_d_bytes)
    # print "new d bytes: %d" % len(low_new_d_bytes)
    sbytes = old_d_bytes + low_new_d_bytes
    # print "length: %d" % len(sbytes)

    m = hashlib.md5()
    m.update(old_d_bytes + low_new_d_bytes)
    digest = m.digest()
    digest_length = len(digest)
    # print "digest_length: ", digest_length
    # print "digest: %s" % hexlify(digest)
    res = ''
    for x in xrange(digest_length):
        res += chr(ord(digest[x]) ^ ord(decrypted[x]))
    print "result: %s" % res
    result = conn.sendline(res)
    feedback = conn.recvline(pwnlib.timeout.Maximum)
    print "feedback: ", feedback
    if feedback.find(CORRECT) >= 0:
        print "Continue..."
        return long_to_bytes(d), res.strip()[-1]
    elif feedback.find(SUCCESS) >= 0:
        return 0, res.strip()[-1]
    else:
        return None, None

def main():

    flag = ''
    host = sys.argv[1]
    port = int(sys.argv[2])

    conn = remote(host, port)

    result = conn.recvuntil('Seed: ')
    seed = conn.recvline(keepends=False)
    # print "seed: ", int(seed, 16)
    print "seed: ", seed
    old_d = unhexlify(seed)
    while True:
        old_d, letter = start(conn, old_d)
        if old_d is None:
            print "Wrong"
            exit(1)
        else:
            flag += letter
            print "Current flag: ", flag
            if old_d == 0: break
    print "FLAG: ", flag


if __name__ == '__main__':
    main()


